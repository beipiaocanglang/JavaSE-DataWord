/**
 * 位运算
 *      &、|、^、~
 *      << 、 >> 、>>>
 *      
 *      & 或位运算 补码操作 有0 则 0
 *      | 与位运算 补码操作 有1 则 1
 *      ^ 位异或运算：相同则0，不同则1
 *          特点：某一个数被同一个数位异或两次 该数的值不变
 *      ~ 按位取反运算：1变0，0变1
 *      << 左移：左边最高位丢弃，右边补齐0
 *      >> 右移：最高位是0，左边补齐0；最高位1，左边补齐1
 *      >>> 无符号右移：无论最高位是0还是1，左边补齐0
 * 注意：
 *      要做位运算首先要讲数据转换成二进制
 *      &、|、^
 *      当左右两边是boolean类型的数据时  她们是逻辑运算符
 *      当左右两边是常量时他们执行的是位运算
 */
public class OperatorDemo {
    public static void main(String[] args){   
        int a = 3;
        int b = 4;

        System.out.println(a & b);//7
        System.out.println(a | b);//7
        System.out.println(a ^ b);//0
        System.out.println(~3);//-4

        //^位异或特点：某一个数被同一个数位异或两次 该数的值不变
        System.out.println(a ^ b ^ b);//3
        System.out.println(a ^ b ^ a);//4


        //<< 把<<左边的数据乘以2的移动次幂
        System.out.println(3 << 2); //3 * 2^2 = 3*4 = 12;
        
        //>> 把>>左边的数据除以2的移动次幂
        System.out.println(24 >> 2); //24 / 2^2 = 24 / 4 = 6
        System.out.println(24 >>> 2);

        System.out.println(-24 >> 2); //-6
		System.out.println(-24 >>> 2);
    } 
}
/**
 * 推算：  
 *       因为要做位运算，所以需要将数据转换成二进制数据
 * 
 * 3的二进制数:11    
 *      00000000 00000000 00000000 00000011
 * 4的二进制数:100
 *      00000000 00000000 00000000 00000100
 * 
 * &位与运算：有0则0
 *      00000000 00000000 00000000 00000011
 *      &
 *      00000000 00000000 00000000 00000100
 *      ———————————————————————————————————
 *      00000000 00000000 00000000 00000000
 *      
 *      结果是：0
 * 
 * |位或运算：有1则1
 *      00000000 00000000 00000000 00000011
 *      |
 *      00000000 00000000 00000000 00000100
 *      ———————————————————————————————————
 *      00000000 00000000 00000000 00000111
 *      
 *      结果是：7
 * 
 * ^位异或运算：相同则0，不同则1
 *      00000000 00000000 00000000 00000011
 *      ^
 *      00000000 00000000 00000000 00000100
 *      ———————————————————————————————————
 *      00000000 00000000 00000000 00000111
 *      
 *      结果是：7
 * 
 * ~按位取反运算：1变0，0变1
 *      3的按位取反结果：
 *          00000000 00000000 00000000 00000011(3是整数，整数的原码、反码、补码都相同，应该以补码进行运算)
 *          ~
 *          11111111 11111111 11111111 11111100(按位取反后的补码)
 *          
 *          补码：11111111 11111111 11111111 11111100(减1得反码)
 *          反码：11111111 11111111 11111111 11111011(反码转原码：符号位不变，其他位是1变0，0变1)
 *          原码：10000000 00000000 00000000 00000100(符号位：1：负号、0：正号)
 *          
 *          结果是：-4
 * 
 *      4的按位取反结果：
 *          00000000 00000000 00000000 00000100
 *          ~
 *          11111111 11111111 11111111 11111011
 *          
 *          补码：11111111 11111111 11111111 11111011
 *          反码：11111111 11111111 11111111 11111010
 *          原码：10000000 00000000 00000000 00000101
 *      
 *          结果：-5 
 * 
 * << 左移
 *      计算出3的二进制：11
 * 		    00000000 00000000 00000000 00000011
 *	    (00)000000 00000000 00000000 0000001100(右移两位，最高位舍弃，最右边补齐0)
 *		
 * >> 右移：	
 *	    计算出-24的二进制：11000
 *		    原码：10000000 00000000 00000000 00011000(负数最高位变1)
 *		    反码：11111111 11111111 11111111 11100111(加1得补码)
 *		    补码：11111111 11111111 11111111 11101000
 *		
 *		    11111111 11111111 11111111 11101000
 *		    1111111111 11111111 11111111 111010(00) 补码
 *		
 *		    补码：1111111111 11111111 11111111 111010（减1得反码）
 *		    反码：1111111111 11111111 11111111 111001(0变1，1遍0 得到原码)
 *		    原码：1000000000 00000000 00000000 000110
 *		
 *		    结果：-6
 *		
 * >>> 无符号右移：
 *		计算出24的二进制：11000
 *		    原码：10000000 00000000 00000000 00011000
 *		    反码：11111111 11111111 11111111 11100111
 *		    补码：11111111 11111111 11111111 11101000
 *		
 *		    11111111 11111111 11111111 11101000
 *		    0011111111 11111111 11111111 111010(00)(补码 最高位是0 就是整数  原、反、补一样，结果是：1073741818)
 *		
 *		结果：1073741818
 */